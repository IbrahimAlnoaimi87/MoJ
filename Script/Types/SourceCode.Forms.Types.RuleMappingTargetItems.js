var SourceCode = SourceCode || {};
SourceCode.Forms = SourceCode.Forms || {};
SourceCode.Forms.Types = SourceCode.Forms.Types || {};

(function ()
{
    var Types = SourceCode.Forms.Types;

    Types.RuleMappingTargetItems = function (options)
    {
        this.mappingItems = {};
        if (options)
        {
            this.addItem(options);
        }

        return this;
    };

    Types.RuleMappingTargetItems.prototype.addItem = function (options, key)
    {
        if (!checkExistsNotEmpty(key))
        {
            key = 0;
            while (this.mappingItems.hasOwnProperty(key))
            {
                key++;
            }
        }

        if (options instanceof Types.RuleMappingTargetItem)
        {
            this.mappingItems[key] = options;
        }
        else
        {
            this.mappingItems[key] = new Types.RuleMappingTargetItem(options);
        }

        return this.mappingItems[key];
    };

    Types.RuleMappingTargetItems.prototype.findItemByKey = function (key)
    {
        return this.mappingItems[key];
    };

    Types.RuleMappingTargetItems.prototype.findItem = function (options)
    {
        return findObjectInArrayMatchingAll({
            queryObject: options,
            targetObject: this.mappingItems,
            splitQueryObjectDelimiter: ",",
            sourcePropertiesContainMultipleValues: true
        });
    };

    Types.RuleMappingTargetItems.prototype.findItems = function (options)
    {
        return findObjectInArrayMatchingAll({
            queryObject: options,
            targetObject: this.mappingItems,
            matchMultiple: true,
            splitQueryObjectDelimiter: ",",
            sourcePropertiesContainMultipleValues: true
        });
    };

    Types.RuleMappingTargetItems.prototype.length = function ()
    {
        return Object.getOwnPropertyNames(this.mappingItems).length;
    };

    Types.RuleMappingTargetItems.prototype.getArray = function ()
    {
        var arr = [];

        for (prop in this.mappingItems)
        {
            if (this.mappingItems.hasOwnProperty(prop))
            {
                arr.push(this.mappingItems[prop]);
            }
        }

        return arr;
    };

    Types.RuleMappingTargetItems.prototype.foreach = function (fn, context)
    {
        if (fn instanceof Function)
        {
            var ownProperties = Object.getOwnPropertyNames(this.mappingItems);
            for (var i = 0; i < ownProperties.length; i++)
            {
                if (checkExists(context))
                {
                    fn.apply(context, [this.mappingItems[ownProperties[i]]]);
                }
                else
                {
                    fn(this.mappingItems[ownProperties[i]]);
                }
            }
        }
    };

    /**
     * @description 
     * @property {string} guid			- Data attribute/value
     * @property {string} targetID		- Data attribute/value
     * @property {string} targetPath	- Data attribute/value
     * @property {string} icon			- Data attribute/value
     * @property {string} itemType		- Data attribute/value
     * @property {string} name			- Data attribute/value
     * @property {string} displayName	- Data attribute/value
     * @property {string} description	- Data attribute/value
     * @property {string} dataType		- Data attribute/value
     * @property {string} instanceId	- Data attribute/value
     * @property {string} subformInstanceId	- Data attribute/value
     * @property {string} subformId		- Data attribute/value
     * @property {string} subType		- Data attribute/value
     * @property {string} watermarkText	- Data attribute/value
     * @property {string} tooltip		- Data attribute/value
     * @property {string} soGuid		- Data attribute/value
     * @property {string} fieldObject	- Data attribute/value
     * @property {string} controlField	- Data attribute/value
     * @property {string} value			- Data attribute/value
     * @property {string} text			- Data attribute/value
     * @property {string} actionPropertyCollection	- Data attribute/value
     * @property {string} required		- Data attribute/value
     * @property {string} grouping		- Data attribute/value generated by BasicaMappingWidget.xslt to indicate grouping type ex: 'Controls'
     * @property {string} visibility	- Data attribute/value
     * @property {string} readonly		- Data attribute/value
     * @property {string} renderLabelAs - Data attribute/value
     * @property {string} renderInputAs - Data attribute/value
     * @property {string} accept      - Data attribute/value (Droppable types that can be accepted)
     * 
     * @property {bool} isMapping		- Widget internal property: Does the item have a tokenbox
     * @property {bool} isReadOnly		- Widget internal property: Used for readonly mappings
     * @property {bool} isInvalid		- Widget internal property: Used for invalid mappings
     * @property {bool} isChecked		- Widget internal property: Mapping checkbox state
     * @property {bool} toBeProcessed	- Widget internal property: If the item should be processed to create it's html.
     * @property {object} listItemElem	- Widget internal property: jQuery reference to DOM element
     * @property {object} parentListItemElem- Widget internal property: jQuery reference to parent DOM element
     * @property {object} tokenboxElem	- Widget internal property: jQuery reference to DOM element
     * @property {object} checkboxElem	- Widget internal property: jQuery reference to DOM element
     * @property {object} itemXmlNode	- Widget internal property: XmlNode reference to item Xml node
     * @property {object} mappingXmlNode- Widget internal property: XmlNode reference to mapping Xml node
     * @property {number} level			- Widget internal property: Indicates the nested level of the node in the hierarchy.
     * @property {bool} renderEnhancedSubType   - Widget internal property: Indicates if a twisty should be rendered based on SubType.
     * 
     * @property {array} mappings		- Widget internal property: Mapping token collection
     * @property {RuleMappingTargetItems} childItems - Widget internal property: RuleMappingTargetItem collection
     * 
     * @param {object} options			- Takes an object with the same properties as the type and sets those values
     * @returns {RuleMappingTargetItem}	- An instance of the RuleMappingTargetItem type
     */
    Types.RuleMappingTargetItem = function (options)
    {
        options = options || {};

        // Item Xml attributes.
        this.guid = options.guid || "";
        this.targetId = options.targetId || null;
        this.targetPath = options.targetPath || null;
        this.icon = options.icon || "";
        this.itemType = options.itemType || "";
        this.name = options.name || "";
        this.displayName = options.displayName || this.name;
        this.description = options.description || null;
        this.dataType = options.dataType || null;
        this.instanceId = options.instanceId || "00000000-0000-0000-0000-000000000000";
        this.subformInstanceId = options.subformInstanceId || "00000000-0000-0000-0000-000000000000";
        this.subformId = options.subformId || "00000000-0000-0000-0000-000000000000";
        this.subType = options.subType || null;
        this.watermarkText = options.watermarkText || "";
        this.tooltip = options.tooltip || "";
        this.soGuid = options.soGuid || null;
        this.fieldObject = options.fieldObject || null;
        this.controlField = options.controlField || null;
        this.value = options.value || null;
        this.text = options.text || null;
        this.actionPropertyCollection = options.actionPropertyCollection || null;
        this.required = options.required || null;
        this.grouping = options.grouping || null;
        this.visibility = options.visibility || null;
        this.readonly = options.readonly || null;
        this.renderInputAs = options.renderInputAs || "tokenbox";
        this.renderLabelAs = options.renderLabelAs || "checkbox";
        this.accept = options.accept || null;

        // BasicMappingWidget internal properties.
        this.allowTextInput = options.allowTextInput || true;
        this.toBeProcessed = options.toBeProcessed || false;
        this.isMapping = options.isMapping || false;
        this.isReadOnly = options.isReadOnly || false;
        this.isInvalid = options.isInvalid || false;
        this.isChecked = options.isChecked || false;
        this.isRequired = options.isRequired || false;
        this.listItemElem = options.listItemElem || null;
        this.parentListItemElem = options.parentListItemElem || null;
        this.parentRuleMappingTargetItem = options.parentRuleMappingTargetItem || null;
        this.tokenboxElem = options.tokenboxElem || null;
        this.checkboxElem = options.checkboxElem || null;
        this.itemXmlNode = options.itemXmlNode || null;
        this.mappingXmlNode = options.mappingXmlNode || null;
        this.level = options.level || null;
        this.renderEnhancedSubType = options.renderEnhancedSubType || false;

        // RuleMappingTargetItem child grouping properties.
        this.mappings = options.mappings || [];
        this.childItems = new Types.RuleMappingTargetItems();

        return this;
    };

    var propNames = {};

    var _ruleMappingTargetItemPrototype =
    {
        populateFromItemXml: function (itemXmlNode)
        {
            this.itemXmlNode = itemXmlNode;

            // Xml Attributes.
            for (var t = 0; t < itemXmlNode.attributes.length; t++)
            {
                var xmlAttr = itemXmlNode.attributes.item(t);
                var xmlAttrNameU = xmlAttr.name.toUpperCase();
                if (propNames.hasOwnProperty(xmlAttrNameU) && checkExistsNotEmpty(xmlAttr.value))
                {
                    this[propNames[xmlAttrNameU]] = xmlAttr.value;
                }
            }

            // Xml Child Nodes.
            for (var t = 0; t < itemXmlNode.childNodes.length; t++)
            {
                var childNode = itemXmlNode.childNodes.item(t);
                var childNodeNameU = childNode.nodeName.toUpperCase();
                if (propNames.hasOwnProperty(childNodeNameU) && checkExistsNotEmpty(childNode.text))
                {
                    this[propNames[childNodeNameU]] = childNode.text;
                }
            }

            if (!checkExistsNotEmpty(this.displayName))
            {
                if (checkExists(this.text))
                {
                    this.displayName = this.text;
                }
                else if (checkExists(this.value))
                {
                    this.displayName = this.value;
                }
                else if (checkExistsNotEmpty(this.name))
                {
                    this.displayName = this.name;
                }
            }
            return this;
        }
    }

    jQuery.extend(Types.RuleMappingTargetItem.prototype, _ruleMappingTargetItemPrototype);

    // Cache RuleMappingTargetItem property names.
    var itemProps = Object.getOwnPropertyNames(new Types.RuleMappingTargetItem());
    for (var i = 0; i < itemProps.length; i++)
    {
        var itemProp = itemProps[i];
        propNames[itemProp.toUpperCase()] = itemProp;
    }

})(jQuery);
